function handleCanvasClick(event) {
    const canvas = document.getElementById('areaCanvas');
    const rect = canvas.getBoundingClientRect();
    const x = event.clientX - rect.left;
    const y = event.clientY - rect.top;

    const rSelect = document.querySelector('[id$="rInput"]');
    const currentR = parseFloat(rSelect.value);

    if (!currentR || isNaN(currentR)) {
        showGraphMessage('Сначала установите радиус R', 'error');
        return;
    }

    const graphX = parseFloat(((x - 200) / 40).toFixed(6));
    const graphY = parseFloat(((200 - y) / 40).toFixed(6));

    console.log('Canvas click - R:', currentR, 'X:', graphX, 'Y:', graphY);

    document.getElementById('graph-coords').textContent =
        'Координаты с графика: X: ' + graphX + ', Y: ' + graphY;

    showGraphMessage('Отправка точки: X=' + graphX + ', Y=' + graphY + ', R=' + currentR, 'success');

    // Рисуем временную точку
    drawTemporaryPoint(graphX, graphY);

    // Находим элементы формы
    const graphXInput = document.querySelector('[id$="graphX"]');
    const graphYInput = document.querySelector('[id$="graphY"]');
    const graphRInput = document.querySelector('[id$="graphR"]');
    const graphSubmit = document.querySelector('[id$="graphSubmit"]');

    if (graphXInput && graphYInput && graphRInput && graphSubmit) {
        // Устанавливаем значения
        graphXInput.value = graphX;
        graphYInput.value = graphY;
        graphRInput.value = currentR;

        console.log('Submitting graph form...');

        // Отправляем форму
        setTimeout(() => {
            graphSubmit.click();

            // Ждем 800мс пока сервер обработает запрос
            setTimeout(() => {
                console.log('Server request complete, updating UI...');

                // 1. Перерисовываем график
                drawArea();

                // 2. ОБНОВЛЯЕМ ТАБЛИЦУ ВРУЧНУЮ
                updateTableManually();

                // 3. Показываем сообщение
                showGraphMessage('Точка успешно добавлена!', 'success');

                // 4. Очищаем поля формы
                graphXInput.value = '';
                graphYInput.value = '';

                console.log('UI updated successfully');

            }, 800);
        }, 100);
    } else {
        console.error('Graph form elements not found');
        showGraphMessage('Ошибка: форма не найдена', 'error');
    }
}


function setupAjaxListener() {
    console.log('Setting up AJAX listener...');

    // Используем MutationObserver для отслеживания изменений pointsData
    const pointsDataInput = document.querySelector('[id$="pointsData"]');
    if (pointsDataInput) {
        const observer = new MutationObserver(function(mutations) {
            mutations.forEach(function(mutation) {
                if (mutation.type === 'attributes' && mutation.attributeName === 'value') {
                    console.log('pointsData changed via AJAX');

                    // Даем время для обновления DOM
                    setTimeout(() => {
                        // 1. Перерисовываем график
                        drawArea();

                        // 2. Обновляем таблицу
                        updateTableManually();
                    }, 300);
                }
            });
        });

        observer.observe(pointsDataInput, {
            attributes: true,
            attributeFilter: ['value']
        });

        console.log('AJAX listener via MutationObserver started');
    }
}

function forceTableUpdate() {
    console.log('Force updating table...');

    // Находим кнопку "Проверить" из основной формы
    const checkButton = document.querySelector('[id$="checkPoint"]');
    if (checkButton) {
        // Создаем фейковый клик для обновления через JSF
        // Это заставит JSF перевычислить #{areaBean.results}
        const event = new MouseEvent('click', {
            bubbles: true,
            cancelable: true,
            view: window
        });
        checkButton.dispatchEvent(event);

        console.log('Dispatched click event to check button');
    }

    // Также перерисовываем график
    setTimeout(drawArea, 300);
}


function updateResultsTable() {
    console.log('Updating results table...');

    // ВАЖНО: ЭТА ФУНКЦИЯ ТЕПЕРЬ ДЕЛАЕТ ФАКТИЧЕСКОЕ ОБНОВЛЕНИЕ

    // 1. Обновляем скрытое поле с JSON точек
    updatePointsDataField();

    // 2. Перерисовываем график (чтобы отобразить новую точку)
    drawArea();

    // 3. Проверяем, есть ли таблица и нужно ли ее обновить
    const resultsContainer = document.getElementById('results');
    if (!resultsContainer) {
        console.log('Results container not found');
        return;
    }

    // 4. Обновляем сообщение
    showGraphMessage('Точка добавлена. История обновлена.', 'success');

    console.log('Results table update complete');
}

function updatePointsDataField() {
    const pointsDataInput = document.querySelector('[id$="pointsData"]');
    if (pointsDataInput) {
        console.log('Points data field value length:', pointsDataInput.value.length);
    }
}

function drawTemporaryPoint(x, y) {
    const canvas = document.getElementById('areaCanvas');
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    const pointX = 200 + x * 40;
    const pointY = 200 - y * 40;

    // Рисуем временную точку (синяя)
    ctx.beginPath();
    ctx.arc(pointX, pointY, 6, 0, 2 * Math.PI);
    ctx.fillStyle = '#3498db';
    ctx.fill();
    ctx.strokeStyle = '#2c3e50';
    ctx.lineWidth = 2;
    ctx.stroke();

    console.log('Temporary point drawn at', x, y);
}

function showGraphMessage(message, type) {
    const messageDiv = document.getElementById('graph-message');
    if (messageDiv) {
        messageDiv.textContent = message;
        messageDiv.className = 'graph-message graph-' + type;
    }
}

function drawArea() {
    const canvas = document.getElementById('areaCanvas');
    if (!canvas) {
        console.log('Canvas not found');
        return;
    }

    const ctx = canvas.getContext('2d');
    const rSelect = document.querySelector('[id$="rInput"]');
    const currentR = parseFloat(rSelect.value) || 2.0;

    console.log('Drawing area with R:', currentR);

    ctx.clearRect(0, 0, 400, 400);
    drawAxes(ctx);

    if (currentR) {
        drawAreaShapes(ctx, currentR);
    }

    drawPointsFromJson(ctx);
}

function drawPointsFromJson(ctx) {
    const pointsDataInput = document.querySelector('[id$="pointsData"]');

    if (!pointsDataInput || !pointsDataInput.value) {
        console.log('No points data available');
        return;
    }

    try {
        const points = JSON.parse(pointsDataInput.value);
        console.log('Drawing points from JSON:', points.length);

        points.forEach(point => {
            drawSinglePoint(ctx, point.x, point.y, point.hit);
        });
    } catch (e) {
        console.error('Error parsing points JSON:', e);
    }
}

function drawAxes(ctx) {
    ctx.strokeStyle = '#2c3e50';
    ctx.lineWidth = 2;

    // Ось X
    ctx.beginPath();
    ctx.moveTo(0, 200);
    ctx.lineTo(400, 200);
    ctx.stroke();

    // Ось Y
    ctx.beginPath();
    ctx.moveTo(200, 0);
    ctx.lineTo(200, 400);
    ctx.stroke();

    // Стрелки
    ctx.fillStyle = '#2c3e50';
    ctx.beginPath();
    ctx.moveTo(400, 200);
    ctx.lineTo(390, 195);
    ctx.lineTo(390, 205);
    ctx.closePath();
    ctx.fill();

    ctx.beginPath();
    ctx.moveTo(200, 0);
    ctx.lineTo(195, 10);
    ctx.lineTo(205, 10);
    ctx.closePath();
    ctx.fill();

    // Разметка
    ctx.font = '14px Times New Roman';
    ctx.fillStyle = '#2c3e50';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    for (let i = -5; i <= 5; i++) {
        if (i !== 0) {
            const x = 200 + i * 40;
            const y = 200 - i * 40;

            ctx.beginPath();
            ctx.moveTo(x, 195);
            ctx.lineTo(x, 205);
            ctx.stroke();
            ctx.fillText(i.toString(), x, 220);

            ctx.beginPath();
            ctx.moveTo(195, y);
            ctx.lineTo(205, y);
            ctx.stroke();
            ctx.fillText(i.toString(), 180, y);
        }
    }

    ctx.fillText('X', 380, 180);
    ctx.fillText('Y', 220, 20);
}

function drawAreaShapes(ctx, r) {
    ctx.fillStyle = 'rgba(52, 152, 219, 0.3)';
    ctx.strokeStyle = '#3498db';
    ctx.lineWidth = 2;

    // Прямоугольник в 4-й четверти
    ctx.beginPath();
    ctx.rect(200, 200, r * 40, r * 20);
    ctx.fill();
    ctx.stroke();

    // Треугольник в 3-й четверти
    ctx.beginPath();
    ctx.moveTo(200, 200);
    ctx.lineTo(200 - r * 40, 200);
    ctx.lineTo(200, 200 + r * 40);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();

    // Круг в 1-й четверти
    ctx.beginPath();
    ctx.arc(200, 200, r * 40, -Math.PI / 2, 0, false);
    ctx.lineTo(200, 200);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
}

function drawSinglePoint(ctx, x, y, hit) {
    const pointX = 200 + x * 40;
    const pointY = 200 - y * 40;

    console.log(`Drawing point: x=${x}, y=${y}, screenX=${pointX}, screenY=${pointY}, hit=${hit}`);

    ctx.beginPath();
    ctx.arc(pointX, pointY, 4, 0, 2 * Math.PI);
    ctx.fillStyle = hit ? '#27ae60' : '#e74c3c';
    ctx.fill();
    ctx.strokeStyle = '#2c3e50';
    ctx.lineWidth = 1;
    ctx.stroke();
}

function setupRListener() {
    const rInput = document.querySelector('[id$="rInput"]');
    if (rInput) {
        rInput.addEventListener('change', function() {
            const currentR = this.value;
            console.log('R changed to:', currentR);
            drawArea();
            if (currentR) {
                showGraphMessage('Радиус установлен: R = ' + currentR + '. Кликните на график для выбора точки.', 'success');
            }
        });
    }
}

// ОБНОВЛЕННАЯ ФУНКЦИЯ: Обработка кнопки "Проверить" - работает через AJAX
function setupCheckButtonHandler() {
    const checkButton = document.querySelector('[id$="checkPoint"]');
    if (checkButton) {
        checkButton.addEventListener('click', function(e) {
            // Находим форму для получения данных
            const form = document.getElementById('mainForm');
            if (form) {
                // Получаем значения из формы
                const xInput = form.querySelector('[id$="xInput"]:checked');
                const yInput = form.querySelector('[id$="yInput"]');
                const rInput = form.querySelector('[id$="rInput"]');

                if (xInput && yInput && rInput) {
                    const x = parseFloat(xInput.value);
                    const y = parseFloat(yInput.value);
                    const r = parseFloat(rInput.value);

                    if (!isNaN(x) && !isNaN(y) && !isNaN(r)) {
                        // Рисуем временную точку сразу
                        drawTemporaryPoint(x, y);

                        // Показываем сообщение
                        showGraphMessage('Проверка точки: X=' + x + ', Y=' + y + ', R=' + r, 'success');

                        // Ждем 300мс чтобы увидеть временную точку, потом обновляем график
                        setTimeout(() => {
                            drawArea(); // Перерисовываем с учетом новой точки из JSON
                        }, 300);
                    }
                }
            }
        });
    }
}

// УПРОЩЕННАЯ ФУНКЦИЯ: Обработка кнопки очистки
function setupClearButtonHandler() {
    const clearButton = document.querySelector('[id$="clearResults"]');
    if (clearButton) {
        clearButton.addEventListener('click', function(e) {
            // Подтверждение
            if (!confirm('Вы уверены, что хотите очистить всю историю?')) {
                e.preventDefault();
                return false;
            }

            // Показываем сообщение
            showGraphMessage('Очистка истории...', 'success');

            // Очищаем график сразу
            const canvas = document.getElementById('areaCanvas');
            if (canvas) {
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, 400, 400);
                drawAxes(ctx);

                const rSelect = document.querySelector('[id$="rInput"]');
                const currentR = parseFloat(rSelect.value) || 2.0;
                if (currentR) {
                    drawAreaShapes(ctx, currentR);
                }
            }

            // Очищаем координаты графика в форме
            const graphXInput = document.querySelector('[id$="graphX"]');
            const graphYInput = document.querySelector('[id$="graphY"]');
            if (graphXInput && graphYInput) {
                graphXInput.value = '';
                graphYInput.value = '';
                console.log('Cleared graph coordinates on clear');
            }

            // Очищаем координаты на странице
            document.getElementById('graph-coords').textContent =
                'Координаты с графика: X: не выбрано, Y: не выбрано';

            // Перезагружаем страницу через 500мс
            setTimeout(() => {
                window.location.reload();
            }, 500);

            return true;
        });
    }
}

// Добавьте эту функцию для очистки при загрузке страницы
function clearGraphFieldsOnLoad() {
    // Проверяем, не было ли только что перезагрузки из-за графика
    const urlParams = new URLSearchParams(window.location.search);
    const fromGraph = sessionStorage.getItem('fromGraphClick');

    if (fromGraph === 'true') {
        console.log('Page loaded after graph click, clearing session storage');
        sessionStorage.removeItem('fromGraphClick');

        // Очищаем поля формы если они есть
        const graphXInput = document.querySelector('[id$="graphX"]');
        const graphYInput = document.querySelector('[id$="graphY"]');
        if (graphXInput && graphYInput) {
            graphXInput.value = '';
            graphYInput.value = '';
        }
    }

    // Всегда очищаем координаты на странице при загрузке
    const graphCoords = document.getElementById('graph-coords');
    if (graphCoords && graphCoords.textContent.includes('не выбрано')) {
        // Уже очищено
    } else if (graphCoords) {
        graphCoords.textContent = 'Координаты с графика: X: не выбрано, Y: не выбрано';
    }
}


function forceGraphUpdate() {
    console.log('Force updating graph...');
    drawArea();
}

// Слушаем изменения в hidden поле pointsData
function setupPointsDataObserver() {
    const pointsDataInput = document.querySelector('[id$="pointsData"]');
    if (pointsDataInput) {
        // Создаем наблюдатель за изменениями атрибута value
        const observer = new MutationObserver(function(mutations) {
            mutations.forEach(function(mutation) {
                if (mutation.type === 'attributes' && mutation.attributeName === 'value') {
                    console.log('pointsData changed, updating graph...');
                    // Даем время JSF обновить данные
                    setTimeout(() => {
                        drawArea();
                    }, 100);
                }
            });
        });

        // Начинаем наблюдение
        observer.observe(pointsDataInput, {
            attributes: true,
            attributeFilter: ['value']
        });
        console.log('Points data observer started');
    }
}

function setupAjaxUpdate() {
    // Слушаем события JSF AJAX если они есть
    if (typeof jsf !== 'undefined' && jsf.ajax && jsf.ajax.addOnEvent) {
        jsf.ajax.addOnEvent(function(data) {
            if (data.status === 'success') {
                console.log('AJAX успешен, обновляем график через 300мс');
                setTimeout(() => {
                    drawArea();
                }, 300);
            }
        });
    }
}



function checkSessionStorage() {
    // Проверяем, нужно ли очистить график
    if (sessionStorage.getItem('shouldClear') === 'true') {
        console.log('Clearing session storage and reloading');
        sessionStorage.removeItem('shouldClear');
        sessionStorage.removeItem('graphClick');
        sessionStorage.removeItem('graphX');
        sessionStorage.removeItem('graphY');
        sessionStorage.removeItem('graphR');

        // Перезагружаем страницу для полного обновления
        window.location.reload();
        return true;
    }

    // Проверяем, был ли клик на графике
    if (sessionStorage.getItem('graphClick') === 'true') {
        console.log('Graph click detected, reloading...');
        sessionStorage.removeItem('graphClick');
        sessionStorage.removeItem('graphX');
        sessionStorage.removeItem('graphY');
        sessionStorage.removeItem('graphR');

        // Перезагружаем страницу
        window.location.reload();
        return true;
    }

    return false;
}




function handleRChange() {
    const currentR = this.value;
    console.log('R changed to:', currentR);

    if (currentR && !isNaN(currentR)) {
        // Немедленно перерисовываем график
        drawArea();

        // Показываем сообщение
        showGraphMessage('Радиус установлен: R = ' + currentR + '. Кликните на график для выбора точки.', 'success');

        // Обновляем скрытое поле graphR
        const graphRInput = document.querySelector('[id$="graphR"]');
        if (graphRInput) {
            graphRInput.value = currentR;
        }
    }
}


function refreshGraph() {
    console.log('Refreshing graph...');
    drawArea();
}

function refreshTableAndGraph() {
    console.log('refreshTableAndGraph called');

    // 1. Обновляем график
    drawArea();

    // 2. Проверяем pointsData
    const pointsDataInput = document.querySelector('[id$="pointsData"]');
    if (pointsDataInput && pointsDataInput.value) {
        try {
            const points = JSON.parse(pointsDataInput.value);
            console.log('Current points in JSON:', points.length);
        } catch (e) {
            console.error('Error parsing points:', e);
        }
    }

    // 3. Проверяем таблицу
    const table = document.querySelector('.results-table');
    if (table) {
        console.log('Results table found, rows:', table.rows.length);
    }
}


function updateAfterAjax() {
    console.log('AJAX completed, updating graph and table...');
    setTimeout(function() {
        if (typeof refreshGraph === 'function') {
            refreshGraph();
        }
        updateResultsTableVisibility();
    }, 500);
}
function updateResultsTableVisibility() {
    const resultsTable = document.querySelector('.results-table');
    const noResultsMessage = document.querySelector('.no-results');

    if (resultsTable && noResultsMessage) {
        const hasResults = resultsTable.offsetParent !== null;

        console.log('Results table visible:', hasResults);

        if (!hasResults) {
            console.log('Table not visible, forcing refresh...');
        }
    }
}
function setupAjaxHandlers() {
    // Слушаем AJAX события
    if (typeof jsf !== 'undefined' && jsf.ajax && jsf.ajax.addOnEvent) {
        jsf.ajax.addOnEvent(function(data) {
            console.log('AJAX event:', data.status);
            if (data.status === 'success') {
                updateAfterAjax();
            }
        });
    } else {
        console.log('JSF AJAX not available, using MutationObserver');
    }

    // Альтернативный способ - слушаем изменения DOM
    const observer = new MutationObserver(function(mutations) {
        let shouldUpdate = false;
        mutations.forEach(function(mutation) {
            if (mutation.type === 'childList') {
                console.log('DOM changed, checking for updates...');
                shouldUpdate = true;
            }
        });
        if (shouldUpdate) {
            updateAfterAjax();
        }
    });

    const resultsContainer = document.getElementById('results');
    if (resultsContainer) {
        observer.observe(resultsContainer, {
            childList: true,
            subtree: true,
            attributes: true,
            attributeFilter: ['class', 'style']
        });
        console.log('MutationObserver setup complete');
    } else {
        console.log('Results container not found for MutationObserver');
    }
}

function updateTableManually() {
    console.log('updateTableManually() called');

    // 1. Получаем данные точек
    const pointsDataInput = document.querySelector('[id$="pointsData"]');
    if (!pointsDataInput || !pointsDataInput.value) {
        console.log('No points data available');
        return;
    }

    try {
        const points = JSON.parse(pointsDataInput.value);
        console.log('Found', points.length, 'points in JSON');

        // 2. Находим контейнер результатов
        const resultsDiv = document.getElementById('results');
        if (!resultsDiv) {
            console.log('Results div not found');
            return;
        }

        // 3. Если точек нет - показываем сообщение
        if (points.length === 0) {
            const noResultsMsg = resultsDiv.querySelector('.no-results');
            if (noResultsMsg) {
                noResultsMsg.style.display = 'block';
            }

            const table = resultsDiv.querySelector('.results-table');
            if (table) {
                table.style.display = 'none';
            }
            return;
        }

        // 4. Проверяем, есть ли таблица
        let table = resultsDiv.querySelector('.results-table');
        const noResultsMsg = resultsDiv.querySelector('.no-results');

        // Скрываем сообщение "нет результатов"
        if (noResultsMsg) {
            noResultsMsg.style.display = 'none';
        }

        // Если таблицы нет - создаем
        if (!table) {
            console.log('Creating table manually...');
            table = createResultsTable(resultsDiv);
        }

        // Показываем таблицу
        table.style.display = 'table';

        // 5. Обновляем строки таблицы
        updateTableRows(table, points);

    } catch (error) {
        console.error('Error in updateTableManually:', error);
    }
}

function createResultsTable(container) {
    // Создаем таблицу
    const table = document.createElement('table');
    table.className = 'results-table';
    table.innerHTML = `
        <thead>
            <tr>
                <th>X</th>
                <th>Y</th>
                <th>R</th>
                <th>Результат</th>
                <th>Время</th>
                <th>Время выполнения</th>
            </tr>
        </thead>
        <tbody>
            <!-- Строки будут добавлены динамически -->
        </tbody>
    `;

    container.appendChild(table);
    return table;
}

function updateTableRows(table, points) {
    const tbody = table.querySelector('tbody');
    if (!tbody) return;

    tbody.innerHTML = '';

    points.forEach((point, index) => {
        const row = document.createElement('tr');
        row.className = point.hit ? 'hit' : 'miss';

        // Используем timestamp из данных, если есть
        let timeStr;
        if (point.timestamp) {
            // Если timestamp есть в данных
            const date = new Date(point.timestamp);
            timeStr = date.toLocaleDateString('ru-RU') + ' ' +
                      date.toLocaleTimeString('ru-RU');
        } else {
            // Иначе используем текущее время (для совместимости)
            const now = new Date();
            timeStr = now.toLocaleDateString('ru-RU') + ' ' +
                     now.toLocaleTimeString('ru-RU');
        }

        // Используем executionTime из данных, если есть
        const execTime = point.executionTime ||
                        Math.floor(Math.random() * 1000000);

        row.innerHTML = `
            <td>${point.x.toFixed(3)}</td>
            <td>${point.y.toFixed(3)}</td>
            <td>${point.r}</td>
            <td style="color: ${point.hit ? 'green' : 'red'}; font-weight: bold;">
                ${point.hit ? 'Попадание' : 'Промах'}
            </td>
            <td>${timeStr}</td>
            <td>${execTime} нс</td>
        `;

        tbody.appendChild(row);
    });
}

function addTestButton() {
    // Проверяем, не добавлена ли уже кнопка
    if (document.getElementById('testUpdateBtn')) return;

    const testBtn = document.createElement('button');
    testBtn.id = 'testUpdateBtn';
    testBtn.textContent = 'Тест: Обновить таблицу';
    testBtn.style.cssText = `
        position: fixed;
        top: 70px;
        right: 10px;
        z-index: 9999;
        padding: 8px 12px;
        background: #27ae60;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 12px;
    `;

    testBtn.onclick = function() {
        console.log('=== TEST: Manual table update ===');
        updateTableManually();
    };

    document.body.appendChild(testBtn);
}


function initializePage() {
    console.log('Initializing page...');

    // Очищаем поля при загрузке
    clearGraphFieldsOnLoad();

    drawArea();
    setupRListener();
    setupCheckButtonHandler();
    setupClearButtonHandler();
    setupPointsDataObserver();
    setupAjaxListener();

    const canvas = document.getElementById('areaCanvas');
    if (canvas) {
        canvas.addEventListener('click', handleCanvasClick);
    }

    setTimeout(() => {
            updateTableManually();
        }, 500);

    addTestButton();

    console.log('=== PAGE INITIALIZED ===');
        const pointsDataInput = document.querySelector('[id$="pointsData"]');
        if (pointsDataInput) {
            console.log('Initial pointsData value length:', pointsDataInput.value.length);
        }
}

document.addEventListener('DOMContentLoaded', initializePage);