module Main where

import Prelude

import Data.Argonaut (class DecodeJson, class EncodeJson, Json, decodeJson, encodeJson, stringify, (.:))
import Data.Argonaut.Core (stringify) as A
import Data.Either (Either(..), either)
import Data.Traversable (for_, traverse_)
import Data.Array (catMaybes, length, mapMaybe, nub, filter)
import Data.Maybe (Maybe(..), fromMaybe)
import Data.Number (fromString)
import Data.String (length) as String
import Effect (Effect)
import Effect.Aff (Aff, launchAff_, makeAff, attempt)
import Effect.Class (liftEffect)
import Effect.Console (log)
import Effect.Ref (Ref)
import Effect.Ref as Ref
import Web.DOM.Document (Document, createElement, toParentNode)
import Web.HTML.HTMLInputElement (checked, fromElement, value)
import Web.DOM.Element (fromNode, getAttribute, setAttribute, toEventTarget, toNode, removeAttribute)
import Web.DOM.Element (toParentNode) as Element
import Web.DOM.NonElementParentNode (getElementById)
import Web.DOM.Node (Node, appendChild, firstChild, insertBefore, setTextContent)
import Web.DOM.ParentNode (QuerySelector(..), querySelector, querySelectorAll)
import Web.Event.Event (EventType(..))
import Web.Event.EventTarget (addEventListener, eventListener)
import Web.HTML (window)
import Web.HTML.Window (document)
import Web.HTML.HTMLDocument as HTMLDocument
import Web.DOM.NodeList (toArray) as NodeList
import Web.Event.Internal.Types (Event)
import Control.Parallel (parTraverse_)

-- –¢–∏–ø—ã –¥–∞–Ω–Ω—ã—Ö
type AppState =
  { x :: Number
  , y :: Maybe Number
  , r :: Array Number
  }

type ValidState =
  { x :: Number
  , y :: Number
  , r :: Array Number
  }

newtype ServerResponse = ServerResponse
  { result :: Boolean
  , now :: String
  , time :: Number
  }

newtype StoredResult = StoredResult
  { x :: Number
  , y :: Number
  , r :: Number
  , time :: String
  , execTime :: String
  , result :: String
  }

-- –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
main :: Effect Unit
main = do
  log "Starting PureScript app..."
  htmlDoc <- document =<< window
  let doc = HTMLDocument.toDocument htmlDoc
  appStateRef <- Ref.new { x: 0.0, y: Nothing, r: [] }

  initXInput appStateRef
  initYButtons appStateRef doc
  initRCheckboxes appStateRef doc
  initFormSubmit appStateRef doc

  log "Initialization complete."

-- –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –≤–≤–æ–¥–∞ X
initXInput :: Ref AppState -> Effect Unit
initXInput appStateRef = do
  htmlDoc <- document =<< window
  maybeElement <- getElementById "x" (HTMLDocument.toNonElementParentNode htmlDoc)
  case maybeElement of
    Nothing -> log "x input not found"
    Just element -> do
      let maybeHtmlInput = fromElement element
      case maybeHtmlInput of
        Nothing -> log "x is not input"
        Just htmlInput -> do
          listener <- eventListener \_ -> do
            val <- value htmlInput
            let parsed = fromMaybe 0.0 (parseNumber val)
            Ref.modify_ (_ { x = parsed }) appStateRef
          void $ addEventListener (EventType "input") listener false (toEventTarget element)

-- –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–Ω–æ–ø–æ–∫ Y
initYButtons :: Ref AppState -> Document -> Effect Unit
initYButtons appStateRef doc = do
  nodeList <- querySelectorAll (QuerySelector ".y-btn") (toParentNode doc)
  nodes <- NodeList.toArray nodeList
  let buttons = mapMaybe fromNode nodes
  log $ "–ù–∞–π–¥–µ–Ω–æ –∫–Ω–æ–ø–æ–∫ Y: " <> show (length buttons)

  traverse_ (\btnElement -> do
    listener <- eventListener \_ -> do
      -- –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Å—Ç–∏–ª–∏ —É –≤—Å–µ—Ö –∫–Ω–æ–ø–æ–∫
      allButtons <- querySelectorAll (QuerySelector ".y-btn") (toParentNode doc)
      allButtonsNodes <- NodeList.toArray allButtons
      let allButtonsElements = mapMaybe fromNode allButtonsNodes
      traverse_ (\b -> do
        setAttribute "style" "" b
        setAttribute "active" "false" b
      ) allButtonsElements

      -- –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å—Ç–∏–ª–∏ –¥–ª—è –∞–∫—Ç–∏–≤–Ω–æ–π –∫–Ω–æ–ø–∫–∏
      setAttribute "style" "background-color: #3498db; color: white;" btnElement
      setAttribute "active" "true" btnElement

      -- –ü–æ–ª—É—á–∞–µ–º –∑–Ω–∞—á–µ–Ω–∏–µ
      maybeVal <- getAttribute "data-value" btnElement
      case maybeVal >>= parseNumber of
        Nothing -> do
          btnText <- textContent (toNode btnElement)
          case parseNumber btnText of
            Nothing -> log $ "–ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–æ–∑–Ω–∞—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ Y: " <> btnText
            Just yNum -> do
              Ref.modify_ (_ { y = Just yNum }) appStateRef
              log $ "Selected Y = " <> show yNum
        Just yNum -> do
          Ref.modify_ (_ { y = Just yNum }) appStateRef
          log $ "Selected Y = " <> show yNum
    void $ addEventListener (EventType "click") listener false (toEventTarget btnElement)
  ) buttons

-- –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —á–µ–∫–±–æ–∫—Å–æ–≤ R
initRCheckboxes :: Ref AppState -> Document -> Effect Unit
initRCheckboxes appStateRef doc = do
  nodeList <- querySelectorAll (QuerySelector "input[name=\"r\"]") (toParentNode doc)
  nodes <- NodeList.toArray nodeList
  let checkboxes = mapMaybe fromNode nodes
  log $ "–ù–∞–π–¥–µ–Ω–æ —á–µ–∫–±–æ–∫—Å–æ–≤ R: " <> show (length checkboxes)

  traverse_ (\cbElement -> do
    let maybeHtmlInput = fromElement cbElement
    case maybeHtmlInput of
      Nothing -> pure unit
      Just htmlInput -> do
        listener <- eventListener \_ -> do
          isChecked <- checked htmlInput
          maybeVal <- getAttribute "value" cbElement
          case maybeVal >>= parseNumber of
            Nothing -> pure unit
            Just rVal -> do
              Ref.modify_ (\st ->
                let newR = if isChecked
                           then nub (st.r <> [rVal])
                           else filter (_ /= rVal) st.r
                in st { r = newR }
              ) appStateRef
        void $ addEventListener (EventType "change") listener false (toEventTarget cbElement)
  ) checkboxes

-- –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –æ—Ç–ø—Ä–∞–≤–∫–∏ —Ñ–æ—Ä–º—ã
initFormSubmit :: Ref AppState -> Document -> Effect Unit
initFormSubmit appStateRef doc = do
  htmlDoc <- document =<< window
  maybeForm <- getElementById "point-form" (HTMLDocument.toNonElementParentNode htmlDoc)
  case maybeForm of
    Nothing -> log "Form not found"
    Just form -> do
      listener <- eventListener \e -> do
        preventDefault e
        state <- Ref.read appStateRef
        log $ "–°–æ—Å—Ç–æ—è–Ω–∏–µ –ø–µ—Ä–µ–¥ –≤–∞–ª–∏–¥–∞—Ü–∏–µ–π: " <> show state

        case validateState state of
          Left err -> do
            log $ "–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏: " <> err
            alert err
          Right validState -> do
            log $ "–í–∞–ª–∏–¥–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ: " <> show validState
            -- –ü–†–û–°–¢–û –í–´–ó–´–í–ê–ï–ú JS –§–£–ù–ö–¶–ò–Æ –î–õ–Ø –ö–ê–ñ–î–û–ì–û R
            for_ validState.r \rVal -> do
              processRequestJS validState.x validState.y rVal
              log $ "–í—ã–∑–≤–∞–Ω processRequestJS —Å R=" <> show rVal
      void $ addEventListener (EventType "submit") listener false (toEventTarget form)

-- –í–∞–ª–∏–¥–∞—Ü–∏—è —Å–æ—Å—Ç–æ—è–Ω–∏—è
validateState :: AppState -> Either String ValidState
validateState state = do
  if state.x < -5.0 || state.x > 3.0
    then Left "X –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤ –¥–∏–∞–ø–∞–∑–æ–Ω–µ –æ—Ç -5 –¥–æ 3"
    else pure unit

  y <- case state.y of
    Just value -> Right value
    Nothing -> Left "–í—ã–±–µ—Ä–∏—Ç–µ –∑–Ω–∞—á–µ–Ω–∏–µ Y"

  if state.r == []
    then Left "–í—ã–±–µ—Ä–∏—Ç–µ —Ö–æ—Ç—è –±—ã –æ–¥–Ω–æ –∑–Ω–∞—á–µ–Ω–∏–µ R"
    else pure unit

  Right { x: state.x, y, r: state.r }

{-
processRequest :: Number -> Number -> Number -> Document -> Aff Unit
processRequest x y r doc = do
  liftEffect $ do
    removeNoResultsMessage doc
    log $ "üü° [1] –ù–∞—á–∞–ª–æ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∑–∞–ø—Ä–æ—Å–∞ –¥–ª—è R=" <> show r

  let fullUrl = "/calculate?x=" <> show x <> "&y=" <> show y <> "&r=" <> show r
  liftEffect $ log $ "üü° [2] –ü–æ–ª–Ω—ã–π URL: " <> fullUrl

  liftEffect $ log $ "üü° [3] –ü–µ—Ä–µ–¥ makeServerRequest"

  result <- attempt $ do
    liftEffect $ log $ "üü° [4] –í–Ω—É—Ç—Ä–∏ Aff makeServerRequest"
    makeServerRequest fullUrl

  liftEffect $ log $ "üü° [5] –ü–æ—Å–ª–µ attempt"

  case result of
    Left error -> do
      liftEffect $ log $ "üî¥ [6] –û—à–∏–±–∫–∞ —Å–µ—Ç–∏: " <> show error
      let errorResult = StoredResult
            { x: x, y: y, r: r
            , time: "N/A", execTime: "N/A"
            , result: "network error"
            }
      liftEffect $ addResultToTable errorResult doc
      liftEffect $ storeResult errorResult

    Right responseStr -> do
      liftEffect $ log $ "üü¢ [7] –ü–æ–ª—É—á–µ–Ω –æ—Ç–≤–µ—Ç, –¥–ª–∏–Ω–∞: " <> show (String.length responseStr)
      case parseServerResponse responseStr of
        Left parseError -> do
          liftEffect $ log $ "üî¥ [8] –û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞: " <> parseError
          let errorResult = StoredResult
                { x: x, y: y, r: r
                , time: "N/A", execTime: "N/A"
                , result: "parse error"
                }
          liftEffect $ addResultToTable errorResult doc
          liftEffect $ storeResult errorResult

        Right serverResponse -> do
          liftEffect $ log $ "üü¢ [9] –£—Å–ø–µ—à–Ω–æ —Ä–∞—Å–ø–∞—Ä—Å–µ–Ω –æ—Ç–≤–µ—Ç"
          let storedResult = createSuccessResult x y r serverResponse
          liftEffect $ addResultToTable storedResult doc
          liftEffect $ storeResult storedResult
          liftEffect $ log $ "‚úÖ [10] –†–µ–∑—É–ª—å—Ç–∞—Ç –¥–æ–±–∞–≤–ª–µ–Ω –≤ —Ç–∞–±–ª–∏—Ü—É"
-}
-- –°–æ–∑–¥–∞–Ω–∏–µ —É—Å–ø–µ—à–Ω–æ–≥–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞
createSuccessResult :: Number -> Number -> Number -> ServerResponse -> StoredResult
createSuccessResult x y r (ServerResponse response) =
  StoredResult
    { x: x, y: y, r: r
    , time: response.now
    , execTime: show response.time <> " ns"
    , result: show response.result
    }

{-
parseServerResponse :: String -> Either String ServerResponse
parseServerResponse str = do
  json <- parseJsonString str
  case decodeJson json of
    Left jsonError -> Left $ "JSON decode failed: " <> show jsonError
    Right response -> Right response
-}
-- –£–¥–∞–ª–µ–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è "–Ω–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤"
removeNoResultsMessage :: Document -> Effect Unit
removeNoResultsMessage doc = do
  let parentNode = toParentNode doc
  maybeNoResults <- querySelector (QuerySelector ".no-results") parentNode
  case maybeNoResults of
    Just element -> removeElement (toNode element)
    Nothing -> pure unit

-- –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ –≤ —Ç–∞–±–ª–∏—Ü—É
addResultToTable :: StoredResult -> Document -> Effect Unit
addResultToTable (StoredResult result) doc = do
  htmlDoc <- document =<< window
  maybeTbody <- getElementById "results-body" (HTMLDocument.toNonElementParentNode htmlDoc)
  case maybeTbody of
    Just tbody -> do
      row <- createElement "tr" doc

      let cells = [ show result.x, show result.y, show result.r,
                    result.result, result.time, result.execTime ]

      for_ cells $ \cellText -> do
        cell <- createElement "td" doc
        setTextContent cellText (toNode cell)
        void $ appendChild (toNode cell) (toNode row)

      -- –î–æ–±–∞–≤–ª—è–µ–º –∫–ª–∞—Å—Å –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞
      if result.result == "true" then
        setAttribute "class" "hit" row
      else
        setAttribute "class" "miss" row

      -- –í—Å—Ç–∞–≤–ª—è–µ–º –≤ –Ω–∞—á–∞–ª–æ —Ç–∞–±–ª–∏—Ü—ã
      firstChild' <- firstChild (toNode tbody)
      case firstChild' of
        Just child -> void $ insertBefore (toNode row) child (toNode tbody)
        Nothing -> void $ appendChild (toNode row) (toNode tbody)

    Nothing -> log "–¢–∞–±–ª–∏—Ü–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞"

-- –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞
storeResult :: StoredResult -> Effect Unit
storeResult result = do
  previous <- _getItem "results"
  let prevResults = case previous of
        Just str -> fromMaybe [] (parseJSON str)
        Nothing -> []
      newResults = [result] <> prevResults
  _setItem "results" (stringify (encodeJson newResults))

-- –í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ –∏—Å—Ç–æ—Ä–∏–∏
restoreHistory :: Effect Unit
restoreHistory = do
  log "–í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∏—Å—Ç–æ—Ä–∏—é..."
  maybeResults <- _getItem "results"
  case maybeResults of
    Just str -> case parseJSON str of
      Just results -> do
        log $ "–ù–∞–π–¥–µ–Ω–æ –∑–∞–ø–∏—Å–µ–π –≤ –∏—Å—Ç–æ—Ä–∏–∏: " <> show (length results)
        doc <- document =<< window
        for_ results $ \result -> addResultToTable result (HTMLDocument.toDocument doc)
      Nothing -> log "–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ –∏—Å—Ç–æ—Ä–∏–∏"
    Nothing -> log "–ò—Å—Ç–æ—Ä–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞"

-- JSON —ç–∫–∑–µ–º–ø–ª—è—Ä—ã
instance decodeJsonServerResponse :: DecodeJson ServerResponse where
  decodeJson json = do
    obj <- decodeJson json
    result <- obj .: "result"
    now <- obj .: "now"
    time <- obj .: "time"
    pure $ ServerResponse { result, now, time }

instance encodeJsonServerResponse :: EncodeJson ServerResponse where
  encodeJson (ServerResponse r) = encodeJson
    { result: r.result
    , now: r.now
    , time: r.time
    }

instance encodeJsonStoredResult :: EncodeJson StoredResult where
  encodeJson (StoredResult result) = encodeJson
    { x: result.x
    , y: result.y
    , r: result.r
    , time: result.time
    , execTime: result.execTime
    , result: result.result
    }

instance decodeJsonStoredResult :: DecodeJson StoredResult where
  decodeJson json = do
    obj <- decodeJson json
    x <- obj .: "x"
    y <- obj .: "y"
    r <- obj .: "r"
    time <- obj .: "time"
    execTime <- obj .: "execTime"
    resultStr <- obj .: "result"
    pure $ StoredResult { x, y, r, time, execTime, result: resultStr }

-- –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏
parseNumber :: String -> Maybe Number
parseNumber str = fromString str

textContent :: Node -> Effect String
textContent node = do
  content <- _textContent node
  pure $ fromMaybe "" content





-- Foreign imports
foreign import parseJsonString :: String -> Either String Json
foreign import removeElement :: Node -> Effect Unit
foreign import _getItem :: String -> Effect (Maybe String)
foreign import _setItem :: String -> String -> Effect Unit
foreign import alert :: String -> Effect Unit
foreign import makeServerRequest :: String -> Aff String
foreign import preventDefault :: Event -> Effect Unit
foreign import _textContent :: Node -> Effect (Maybe String)
foreign import parseJSON :: String -> Maybe (Array StoredResult)
foreign import processRequestJS :: Number -> Number -> Number -> Effect Unit
foreign import processRequestAff :: Number -> Number -> Number -> Aff { result :: Boolean, now :: String, time :: Number }